# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
  1) разведки местности,
  2) добычи ресурсов
  3) доставки ресурсов в хабы
  4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS (bitECS)
- сериализация данных для транспортировки — bitECS/serialize
- Физика - Rapier2D (WASM)
- рендер - Pixi.js (WebGL)
- реалтайм-транспорт — uWebSockets.js или webrtc, пока решение не принято

## Архитектура кода
- в основу положена ECS архитектура
- используется bitecs последней версии 0.4
- версия важна, потому что в 0.4 много breaking changes и новых подходов
- если не уверен по поводу актуальности собственных знаний — загляни в [bitecs.md](./bitecs.md) файл, там локальная копия доки
- за обработку всей логики отвечает логическая версия ecs-мира (далее lecs, Logic ECS)
- за отображение игры отвечает визуальная версия ecs-мира (далее vecs, Visual ECS)
- lecs сериализует ограниченное кол-во сущностей и компонентов и передаёт в vecs через сеть
- lecs запускается только в браузере, это мир только для рендеринга картинки и юзер инпута
- vecs запусккается и в браузере(сингл плеер/хост мод) и на сервере(режим выделенного сервера)

## ECS отношения
- название отношения начинается с `r_`
- отношения лежат в папке src/relations

## ECS компоненты
- компоненты должны содержать в себе наименьшее кол-во данных
- название компонента начинается с `c_`
- лежат в папке src/components
- разделены по мирам: общие, lecs-only и vecs-only
- общие начинаются с `n_` (`n_c_position`)
- lecs-only начинаются с `l_` (`l_c_activeHead`)
- vecs-only начинаются с `v_` (`v_c_label`)
- компоненты хранят в себе только данные, которые bitecs может сериализовать(то есть типизированные списки и поставляемые из bitecs обертки над массивами)

## ECS системы
- системы должны содержать в себе наименьшее кол-во логики на единицу системы
- название системы начинается с `s_`
- системы, необходимые в обоих мирах(lecs и vecs) находятся в папке src/commonSystems
- системы, необходимые только в lecs лежат в папке src/logicSystems
- системы, необходимые только в vecs лежат в папке src/visualSystems
- системы разделены по мирам: общие, lecs-онли и vecs-онли
- общие системы начинаются с `n_` (`n_s_sub_bodyAddSystem`)
- lecs-only системы начинаются с `l_` (`l_s_tick_applyUserInput`)
- vecs-only системы начинаются с `v_` (`v_s_tick_renderLightnig`)
- разделены по типам: 
  - `sub` - разово вызывается при старте, возвращает функцию отписки
  - `tick` - вызывается раз в определенный период времени(как FixedUpdate в юнити)
- в итоге имя системы состоит из мира, типа и имени: `[world]_[type]_[nameInCamelCase]`

## Физика
- для просчёта физики в lecs поднимается rapier.js мир, который обновляется(world.step()) раз в тик системы ecs
- для просчёта коллизий, рейкастов и геометрии в vecs поднимается rapier.js мир, который обновляется исключительно данными из сетевого транспорта, world.step() не вызывается
- vecs версия физики сглаживает сетевые обновления позиций объектов при помощи интерполяции

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние
- для сингл-плеер мода нетворк транспорт(S_SO_Transport) будет заменяться на локальный транспорт(S_CO_Transport), который почти напрямую будет передавать данные в vecs
- для дев-мода S_CO_Transport будет имитировать задержку и джиттеры для тестирования синхронизации клиента и сервера

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

## Управление
- TBD

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## Стек
- TypeScript
- Pixi.js 8
- @dimforge/rapier2d
- bitECS
- Webpack 5
