# Что это?
- мультиплеерная игра Cavetronic
- 2D-игра с видом сбоку про дронов, которые исследуют бесконечные пещеры, пытаясь выбраться на поверхность
- чтобы преодолевать большие расстояния под землей игроку придется бурить дыры в стенах
- чтобы бурить стены, понадобятся инструменты и электричество
- чтобы создавать инструменты, требуется перерабатывать определенные ресурсы
- чтобы создавать электричество, требуется сжигать определенные ресурсы
- добыче ресурсов препятствуют постоянно спавнящиеся противники и хрупкость мира
- геймплейный цикл состоит из следующих повторяющихся итераций
  1) разведки местности,
  2) добычи ресурсов
  3) доставки ресурсов в хабы
  4) переработки ресурсов в инструменты и электричество

## Геймплейные цели игры
- основная цель — добраться до двух точек интереса, расположенных на большом удалении от начальной точки возрождения игрока
- первая точка интереса — поверхность, там игрок узнает о ситуации, которая заставила дронов добывать под землей ресурсы
- вторая точка интереса - ядро планеты, там игрок завершает сюжетную линию, находя специальный предмет и финального босса

## Референсы
- `terraria` — отсюда вид сбоку, пещеры, добыча руды и агрессивные противники с большим спавн рейтом
- `factorio` — отсюда система заводов, логистика ресурсов, автоматизация производства, автоматические дроны

## Особенности игры
- глубокая интеграция физической симуляции
- почти все объекты в игре — физически корректные тела, которые реагируют на внешний мир
- добыча ресурсов — это в буквальном смысле откалывание кусков породы от стен
- транспортировка ресурсов предполагает наличие специального транспорта, который нужно "тянуть за собой"
- переработка ресурсов предполагает физическое помещение ресурса в обрабатывающие механизмы при помощи труб

## Архитектура софта
- Сервер-авторитарная модель
- структура логики - ECS (bitECS)
- сериализация данных для транспортировки — bitECS/serialize
- Физика - Rapier2D (WASM)
- рендер - Pixi.js (WebGL)
- реалтайм-транспорт — uWebSockets.js или webrtc, пока решение не принято

## Архитектура кода
- в основу положена ECS архитектура
- используется bitecs последней версии 0.4
- версия важна, потому что в 0.4 много breaking changes и новых подходов
- если не уверен по поводу актуальности собственных знаний — загляни в [bitecs.md](./bitecs.md) файл, там локальная копия доки
- за обработку всей логики отвечает логическая версия ecs-мира (далее lecs, Logic ECS)
- за отображение игры отвечает визуальная версия ecs-мира (далее vecs, Visual ECS)
- lecs сериализует ограниченное кол-во сущностей и компонентов и передаёт в vecs через сеть
- vecs запускается только в браузере, это мир только для рендеринга картинки и юзер инпута
- lecs запусккается и в браузере(сингл плеер/хост мод) и на сервере(режим выделенного сервера)

## Worker-архитектура
- lecs работает в отдельном Worker (src/workers/lecs.worker.ts), vecs — на main thread
- это обязательно даже в dev: bitecs компоненты — глобальные TypedArray, lecs и vecs на одном потоке затирали бы данные друг друга
- в воркере вместо requestAnimationFrame используется setTimeout-based loop (src/utils/workerLoop.ts)
- webpack 5 автоматически создаёт отдельный бандл для воркера через `new Worker(new URL('./path', import.meta.url))`

## Сервисы (DI-токены)
- глобальные зависимости (физика, рендер, и т.д.) доступны через токены, а не напрямую из world объекта
- токен — типизированный symbol: `createToken<T>(name)` (src/services/createToken.ts)
- получение сервиса: `getService(world, Token)` (src/services/getService.ts)
- world хранит `services: ServiceContainer` (Map), createEcsWorld принимает эту Map извне
- внешние сервисы (приходят из LECS.ts/VECS.ts): PhysicsToken, PixiAppToken
- внутренние сервисы (регистрирует createEcsWorld): GetIndexToken, GetDeltaTimeMsToken
- каждый токен — отдельный файл в src/services/
- системы кешируют сервисы один раз при подписке (до observe), не дёргают getService в горячих колбэках

## ECS отношения
- название отношения начинается с `r_`
- отношения лежат в папке src/relations

## ECS компоненты
- компоненты должны содержать в себе наименьшее кол-во данных
- название компонента начинается с `c_`
- лежат в папке src/components
- разделены по мирам: общие, lecs-only и vecs-only
- общие начинаются с `n_` (`n_c_position`)
- lecs-only начинаются с `l_` (`l_c_activeHead`)
- vecs-only начинаются с `v_` (`v_c_label`)
- компоненты хранят в себе только данные, которые bitecs может сериализовать(то есть типизированные списки и поставляемые из bitecs обертки над массивами)

## ECS системы
- системы должны содержать в себе наименьшее кол-во логики на единицу системы
- название системы начинается с `s_`
- системы, необходимые в обоих мирах(lecs и vecs) находятся в папке src/commonSystems
- системы, необходимые только в lecs лежат в папке src/logicSystems
- системы, необходимые только в vecs лежат в папке src/visualSystems
- системы разделены по мирам: общие, lecs-онли и vecs-онли
- общие системы начинаются с `n_` (`n_s_tick_syncBodies`)
- lecs-only системы начинаются с `l_` (`l_s_tick_applyUserInput`)
- vecs-only системы начинаются с `v_` (`v_s_tick_renderLightnig`)
- все системы - это `tick` системы: вызываются раз в определенный период времени(как FixedUpdate в юнити)
- если нужна "моментальная" обработка - система вызывается вручную внутри другой системы
- в итоге имя системы состоит из мира, типа и имени: `[world]_s_tick_[nameInCamelCase]`

## Физика
- для просчёта физики в lecs поднимается rapier.js мир, который обновляется(world.step()) раз в тик системы ecs
- для просчёта коллизий, рейкастов и геометрии в vecs поднимается rapier.js мир, который обновляется исключительно данными из сетевого транспорта, world.step() не вызывается
- vecs версия физики сглаживает сетевые обновления позиций объектов при помощи интерполяции

## Мультиплеер
- кол-во игроков — 2–4
- Сервер управляет симуляцией, клиенты получают состояние
- для сингл-плеер мода нетворк транспорт(S_SO_Transport) будет заменяться на локальный транспорт(S_CO_Transport), который почти напрямую будет передавать данные в vecs
- для дев-мода S_CO_Transport будет имитировать задержку и джиттеры для тестирования синхронизации клиента и сервера

## Мир
- Процедурная генерация мира
- Мир бесконечный в ширину и глубину, вверху имеется небольшой слой "поверхности"
- мир представляет собой бесконечные пещеры (тоннели)

## Управление
- TBD

## Графика
- зелено-чёрная графика имитирующая старый терминал
- TBD

## TypeScript код стайл:
- Максимум 30 строк на функцию (сложная — с композицией)
- Декларация функций: function name() {} вместо лямбд
- `if () {}` (и прочие места, где можно не ставить фигурные скобки) — строго с фигурными скобками
- Пробелы между логическими блоками (не "сплошной код")
- Комментарии — только JSDoc в начале функции
- Один файл — одна логическая функция (модульность), то есть:
  - функции хелперы могут быть в файле с логической функции
  - две логических функции не могут находиться в одном файле
- не аллоцируем лишних объектов в горячих участках кода


## Документация архитектурных решений
- все важные архитектурные решения по подсистемам описываются в папке `docs/`
- каждая подсистема — отдельный файл (например `docs/transport.md`, `docs/serialization.md`, `docs/physics.md`)
- ссылки на эти файлы приведены ниже, чтобы Claude мог подгрузить нужный контекст в начале сессии
- при принятии нового архитектурного решения — обновить соответствующий doc-файл

### Ссылки на документацию
- [Транспорт и сериализация](./docs/transport.md) — ITransport, IHostTransport, HostTransport, Worker-каналы, формат пакетов, frame numbering, snapshot/delta flow
- [bitecs](./bitecs.md) — локальная копия документации bitecs 0.4

## Стек
- TypeScript
- Pixi.js 8
- @dimforge/rapier2d
- bitECS
- Webpack 5
